{
    "TÃ­tulo": "Project Report: U-Net Kernel Endpoint",
    "Cuerpo": "There are at least two ways that this problem can be solved. One idea is to implement the required services through a library of user level functions that use U-Net as the transport mechanism. Another approach is to actually construct an endpoint inside of the kernel, and allow it to access the network hardware via the U-Net device driver. Once the kernel endpoint is in place, any type of data can be transmitted across the network, regardless of protocol. Our idea is to take advantage of the \"virtual network interface\" provided by the U-Net driver and to treat it as a real network card inside of the kernel. While any communication using the kernel endpoint will no doubt be slower than user-level endpoints, the idea is to allow many applications to multiplex on one kernel endpoint and for existing socket-based apps to at least run.The idea is not to implement IP or other high-level protocols; but essentially to replace the low-level kernel functions for sending data to an ATM or Ethernet card with routines which read/write to the kernel endpoint. Project milestones March 28 : Project Proposal We have met with Matt Welsh to get a better idea of what this project will involve. We believe that the best platform for this project will be on a PC running Linux, using Fast Ethernet hardware. Ideally, the abstraction provided by U-Net should allow our code to also work across the ATM hardware, but whether this proves to be true remains to be seen and is beyond the scope of this project. It is our understanding that the basic idea of this project is to provide the ability for the kernel to access the U-Net interface via the already written U-Net driver. With this basic setup, we have divided the project into two basic parts, so that each of us can concentrate on one of them, (1) kendpt-lib : a kernel-level implementation of devtulip and libunet. Issue 2 : To make one of the U-Net endpoints behave as the 'Kernel-Endpoint', this requires changes to be made in the U-Net code to force the 'Kernel-Endpoint' to the kernel space.This issue requires a thorough understanding of the U-Net architecture and driver code. On a large network, we can't maintain a channel per host, but the overhead of activating a channel is probably too substantial for us to activate and deactivate once for every transmitted packet. We'll have to rewrite what we need so that it will work inside of the kernel, and add it to the module. From U-Net we need to pick up the packets and pass it on to the IP. (April 24) We considered polling as 'cpu time wasting' and signals are not useful in kernels. (April 28) Hey... there can still be further increase in efficiency! But, we need our code to be portable for the ATM... plus later on Matt plans to provide an interface which would let user processes multiplex via the kernel endpoint without the IP, so its more flexible if the interface looks just like U-Net. The majority of the code is written, and all of the major issues seem to be resolved. Expected Overhead and Future Extensions Thanks a lot ... to our Instructor, Thorsten von Eicken for providing us with the opportunity (and hardware) to work on this project, and Matt Welsh for maintaining his patience while explaining (and re-explaining) the U-Net driver internals as well as providing us with guidance throughout this project.",
    "ground_truth": "unknown"
}