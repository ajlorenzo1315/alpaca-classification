{
    "TÃ­tulo": " CS415 Questions and Answers ",
    "Cuerpo": "We don't understand what removeProc is supposed to do. Are we to scan down procTable for the first element which has a tail-pointer (by which we assume you mean the element p_next of some structure of type proc_t) identical to (*tp)? Consider a queue q (A queue is a FIFO list with a \"head\" element and a \"tail\" element). How you do it (namely, how you devise a \"smart\" and efficient implementation of the queue data structure that makes this task easy) it is up to you... :-) Question: I cannot read files types.h and const.h . What should I do? Also, the tail pointer (which by the way must point to the last element in the queue) does have to point to an element of type proc_t. Gcc produces executable for your SPARC, not for CHIP. Because of the above point, you will have to eventually compile your files using pcc. If you used ANSI C in your gcc code, you will have to change it back to pre-ANSI notation. As far as accessing that area, if you look in const.h you will find the following definition: #define BEGINDEVREG     01400   /* beginning of device registers */ that should be what you are looking for. if there is a process waiting on the i/o semaphore for the device that returned the values, then you can simply copy the values in the registers 2 and 3 of the process that is waiting. if there is no process waiting, you should copy the returned value in the buffer dedicated to the device (the one that you declared at initialization time). Answer: Let me answer the question is reverse order. It is not your job (at least for now) to decide *how* to initialize those areas: you can just assume that they are initialized through the values passed in registers 2, 3, and 4. Passing up a trap really means invoking a trap handler that is not located in the nucleus, but rather in a higher layer of the operating system. Before a trap can be passed up, the appropriate old and new trap areas for the calling process must be initialized (calling SYS5). Passing up the trap involves copying the state of the calling process into the old area, and copying the state contained in the new trap area in the calling process' state as it is maintained in the process table. As you can see, to \"load\" the new state we are not using LDST. In mine, the reason why the caller may be different from the running process is easy to see if we consider the SYS trap handler, and we concentrate on SYS4, As a result of the P operation, the calling process may be blocked, and a new process elected to be the next to run. If the caller process has not executed SYS5, the caller will be terminated, and a new process will be designated as the next to run.",
    "ground_truth": "unknown"
}