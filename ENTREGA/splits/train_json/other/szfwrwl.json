{
    "TÃ­tulo": "CSE 531 Bboard/Mail Log\n",
    "Cuerpo": "We will use this list for announcements of general interest to the class. Here's the way I read the > question: > > Let N(n) be the set of all NFAs with n states. We must find a function f(n) > such that *no* NFA in N(n) has an equivalent DFA containing fewer than f(n) > states. The problem doesn't ask you to find f(n) s.t. Lemma 1.27 referred to in problem 1.10 contains the proof for showing the construction of NFAs for regular expressions. Since Sipser text is not out yet, Hopcroft Ulman's text is a good substitute for these topics as the Sipser's treatment is quite similar to H&U's. I can get you copies of the relevant sections of the text. -------------------------------------------------------------------------- From: nitin@june (Nitin Sharma) Subject: Re: cse531 To: kayee@june.cs.washington.edu (Ka Yee Yeung) Date: Mon, 14 Oct 1996 13:09:15 -0700 (PDT) Cc: cse531@june > > I think you'll have office hour today at 3:30. -nitin From: nitin@june (Nitin Sharma) Subject: Re: Subset construction's optimality To: gjb@sturgeon.cs.washington.edu (Greg Badros) Date: Wed, 16 Oct 1996 17:00:49 -0700 (PDT) Cc: cse531@june > > To paraphrase the other question about the question posed on the HW, I, > too, must be missing something obvious, because I'd think the family of > NFA-s the question mentions (nth character from end is a \"1\") is a n+1 > state NFA which can't be reduced to a DFA w/ fewer than 2^(n+1) states, > so f(n) can be as big as is possibly could be; that is, f(n) = n^2. But that will prove f(n) = 2^n, and not n^2. If you find it tough, come up with as high a lower bound on f(n) as you can. -nitin To: cse531@cs Subject: Re: Subset construction's optimality <199610170000.RAA15729@june.cs.washington.edu> Date: Wed, 16 Oct 1996 17:08:44 PDT From: Brian K Dewey <dewey@scoter.cs.washington.edu> To throw in my own two cents. > > > > To paraphrase the other question about the question posed on the HW, I, > > too, must be missing something obvious, because I'd think the family of > > NFA-s the question mentions (nth character from end is a \"1\") is a n+1 > > state NFA which can't be reduced to a DFA w/ fewer than 2^(n+1) states, > > so f(n) can be as big as is possibly could be; that is, f(n) = n^2. Actually, isn't the n-th character from the end a \"1\" set of languages a set that requires n+1 states in an NFA, but 2^n states in a DFA? >  But that will prove f(n) = 2^n, and not n^2. > > > > > > > To paraphrase the other question about the question posed on the HW, I, > > > too, must be missing something obvious, because I'd think the family of > > > NFA-s the question mentions (nth character from end is a \"1\") is a n+1 > > > state NFA which can't be reduced to a DFA w/ fewer than 2^(n+1) states, > > > so f(n) can be as big as is possibly could be; that is, f(n) = n^2. > > Actually, isn't the n-th character from the end a \"1\" set of languages a set > that requires n+1 states in an NFA, but 2^n states in a DFA? > >  But that will prove f(n) = 2^n, and not n^2. \\begin{enumerate} \\item Text 1.14(b,c). \\item However, prove that there is a constant $c$ such that every $w \\in L(M)$ is accepted by {\\em some\\/} computation of length at most $c(n+1)$, where $n=|w|$.",
    "ground_truth": "other"
}