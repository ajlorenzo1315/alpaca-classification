{
    "TÃ­tulo": " Lecture notes - Chapter 9 - Procedures",
    "Cuerpo": "Steps in the execution of the procedure: 1. save return address 2. procedure call 3. execute procedure 4. return what is procedure call? does 2 things 1.  it places the address of the instruction following it into register $ra ($31). The code (skeleton) for one of these procedures: A:  jal C jal D jr $ra Some notes on this: -- the allocation and removal of a frame should be done within the body of the procedure. What call by value really implies is that the procedure can modify the value (copy) passed to it, but that the value is not changed outside the scope of the procedure. add  $4, $20, $0     # put parameter in register 4 jal decrement move $20, $4         # recopy parameter to its correct place. place the parameters to a procedure (function) in the activation record for the procedure. MIPS convention -- when passing parameters in registers, the first 4 parameters are passed in registers $4-7. If there are nested subroutine calls, and registers $4-7 are used for parameters, the values would be lost (just like the return address would be lost for  'jal' if not saved). For recursive calls, current parameters are stored on the stack before a nested call. to set up a call to proc2, place current parameters (in $4-7) into AR of procedure allocate AR for proc2 set up parameters to proc2 in $4-7 call proc2 (jal proc2) copy any return values out of $2-3, $4-7 pop current parameters from stack back to $4-7 # a is in register 20 # b is in register 21 # switch is a procedure to switch its 2 parameters, and then #   decrement each of the 2 parameters #   $a0 ($4) -- first parameter #   $a1 ($5) -- second parameter #   $8 -- temporary for switching s_and_d:   sub  $sp, $sp, 20     # allocate frame for switch sw   $ra, 20($sp)     # save return address on stack Summary and other ideas: 1.  use registers + easy, and don't have to store data in memory (faster) - limited number of registers - doesn't work for recursion, and must be careful when using it where there are nested subroutines 2. use some registers, and place the rest on the stack + since many procedures have few parameters, get the advantages of (1) most of the time. Call it a FRAME POINTER. On the MIPS, all data with a stack frame is accessed via the stack pointer, $sp. place current parameters into current stack frame save any temporary registers that need to be preserved across the procedure call allocate space for ALL parameters frame (AR) for procedure to be called (move $sp to give enough space for the procedure's parameters) place first 4 parameters to procedure into $a0-$a3 place remainder of parameters to procedure into newly allocated space restore (copy) return address from stack frame into $ra restore from stack frame any saved registers (saved in prologue) de-allocate stack frame (or most of it) (move $sp so the space for the procedure's frame is gone) copy needed return values and parameters from $v0-v1, $a0-a3, or stack frame to correct places de-allocate remainder of procedure's stack frame (move $sp so the space for the procedure's frame is gone) restore any temporary registers from stack frame (saved in call setup)",
    "ground_truth": "other"
}