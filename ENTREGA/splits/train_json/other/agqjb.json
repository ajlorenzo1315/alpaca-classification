{
    "TÃ­tulo": " Mobile Object Layer for Dynamic and Irregular  Computations ",
    "Cuerpo": "The work consisted of two parts: Implementing a runtime library (\"Mobile Objects\") to handle migration of objects from one processor to another, and to handle the communication between these objects Parallelizing an adaptive mesh refinement (AMR) program on top of Mobile Objects and PORTS The AMR algorithm starts with a uniform mesh (on which a pde can be solved) and recursively refines areas of the mesh that need a finer mesh to achieve the desired level of accuracy in the pde solution. Our approach was to break up the mesh into small pieces called \"Grid Components\", and then balance the load by transferring grid components from heavily loaded processors to lightly loaded processors. The AMR algorithm on grid components as follows:  The mesh starts out as a single root grid component. In order to balance the load, grid components can move from one processor to another. To keep track of mobile pointers, each processor has a directory which it uses to hold the location of mobile objects. The entries in the directory may not be current, so messages can be sent out to the \"best guess\" at where the object resides, and the messages will be forwarded to the true location of the object. The current interface to the Mobile Objects layer is contained in mobile.h. To send a message to an object specified by a mobile pointer, a processor checks the table corresponding to the originating processor of the mobile pointer. Once an entry has been looked up in the directory, a message can be sent to the mobile object on a remote processor. An application can call mob_ObjReq to send out a \"request for object\" from one processor to another. This request invokes a user handler at the remote processor which selects an object and sends the object back to the requesting processor. To send a message to an object, the application calls mob_MsgReq . This sends a small message to the processor that holds the object specified by a mobile pointer. The current implementation of mob_ObjReq and mob_MsgReq uses the PORTS functions ports1_put and ports1_rsr_handler . The AMR program creates one mobile object per grid component to handle the grid component data, and uses one thread for each grid component to handle control. If a processor receives a request for grid components, it checks its list of available grid components to see if it has any work to send out. These measurements are shown as functions of time, so that it is apparent how the balance of computation and communication change as the mesh refinement progresses. However, as the computation progresses, the processors spend more and more time fetching components, because the components are near the bottom of the grid component tree and therefore lead to relatively little work. As the above plots show, AMR is difficult to load balance, because of the explosive growth of the grid component tree in unpredictable places. In an application using AMR, the grid component tree is similar in structure from one time step to the next (in fact, it may be held fixed for several time steps), so refinements are no longer completely unpredictable and load balancing can occur more gradually over many time steps.",
    "ground_truth": "other"
}