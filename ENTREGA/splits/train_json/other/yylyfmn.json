{
    "TÃ­tulo": "Debugging Using GDB",
    "Cuerpo": "Contents Introduction GDB and Debugging Using GDB on a Program that Crashed Using Gdb on a Program that Produces Incorrect Output Additional Gdb Commands Summary of Gdb Commands Introduction Once you've written your program and it correctly compiles, you must thoroughly test it. When a program crashes, if you run the program under the control of gdb , you will get a chance to inspect the state of the program at the moment it crashed. (However, note that many systems \"buffer\" output, so it sometimes happens that a program may produce part of an output line that was never printed because of the program crashed. A good start is the where command, which will tell us more about the context in which the crash occurred: (gdb) where #0  0x15664 in init (str=0x5 <Address 0x5 out of bounds>) at bug1.C:10 #1  0x15730 in main () at bug1.C:27 (gdb) This shows the call stack , the sequence of function calls in progress at the point of termination. Gdb has a command to list files (named list ): (gdb) list 5       { 6         int i; 7 8     for (i = 1; i <= i++) 9       { 10         *(str++) = 'x'; (Sometimes you will want to create a new window and look at the file in question using your favorite editor -- after all, you'll probably want to correct the bugs once you find them!) The command up will take us up one call ( down takes us back down the call stack): (gdb) up #1  0x23a4 in main () at bug1.C:27 27          init(strs[i]); Because we've moved up the call stack, the current procedure is now main , and the current position in the code is now line 27 of function main : (gdb) list 22          strs[i] = new char [11]; 23        } 24 25    for (i= 1; i <= 4; i++) 26      { 27        init(strs[i]); 28      } 29 30    for (i= 1; i <= 4; i++) 31      { We can now look at the values of variables visible in main . Summarizing, what we were able to find out by using gdb was the following: The program incorrectly went beyond the end of strs and tried to use the value of i as a string pointer. Using Gdb on a Program that Produces Incorrect Output When a program crashes, at least you have a starting point at which to begin the debugging process: You look at the line that was about to be executed when the crash occurred and try to determine why the program misbehaved. When we compile and run we get the following: > g++ -g -Wall -o bug2 bug2.C > bug2 The number of adjacent values that are equal is 9 The program terminates cleanly (i.e., no run-time error is reported), but when we look at the values that array a was given in line 3, we see that the answer computed -- 9 -- is plainly wrong! For example, a program usually called as testprog -f file1 would be run from within gdb by issuing the command run -f file1 Standard input is entered from the keyboard; standard output appears on the screen, possibly intermixed with the output from gdb commands. End Remark To get gdb to stop while running a program (so that we can look at values, for example), we use the break command (which can be abbreviated b ). Each time that function or line number is reached, gdb stops and waits for additional commands (such as a command to print the value of some variable, or a command to resume execution). (gdb) p i $1 = 2 (gdb) p a[i] $2 = 5 (gdb) p a[i+1] $3 = 3 These values look ok. At a breakpoint, the line that gdb shows you is the next line to be executed, so we are just about to execute \" if (a[i] = a[i+1]) \". In our example program bug2.C , line 14 would be a good place to set a breakpoint, since it is where variable cnt is incremented. This allows you to give a collection of gdb commands that are executed (by gdb ) each time a certain breakpoint is encountered. This is especially useful when you are trying to keep an eye on a number of variables; you just tell gdb to print all their values at the breakpoint, rather than typing in print commands by hand every time gdb stops at the breakpoint. For instance, in our example of debugging program bug2 , we could have had the values of cnt , a[i] , and a[i+1] printed out each time the breakpoint at line 14 was encountered: > gdb bug2 . Remember that if you forget the details of a command, you should say help command and gdb will give you some information about the command. The document Using GDB details all that's available. quit             Terminate gdb where            Show the call stack where execution has been halted p                Print the value of a variable or expression up               Refocus gdb up one function in the call stack down             Refocus gdb down one function in the call stack help             Get help for a command run              Start execution of a program b                Set a breakpoint at a line or function clear            Clear a breakpoint from a line or function commands         Set commands to be executed when a breakpoint is hit s                Execute one more line (possibly in a subroutine) n                Execute to next line of current function continue         Continue execution to next breakpoint watch            Watch for a change in an expression (this can be slow) list             List source lines of a function Here are some other commands that we did not discuss but which are very useful: Command          Effect",
    "ground_truth": "other"
}