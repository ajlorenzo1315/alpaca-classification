{
    "TÃ­tulo": "Index of /~cao/traces/",
    "Cuerpo": "The applications are: Access pattern: the trace file is read sequentially multiple times; cscope1 (j2-trace): cscope searching symbol names in a large kernel source; Access pattern: the database file is read sequentially multiple times; cscope2 (j4-trace): cscope searching text strings in a large kernel source; Access pattern: collection of multiple source-code files read in the same order sequentially multiple times; cscope3 (j3-trace): cscope searching text strings in a small kernel source; Access pattern: collection of multiple source-code files read in the same order sequentially multiple times; * The difference between cscope2 and cscope3 is that cscope2's data set is larger than cscope3's. Index files are read sequentially multiple times, and based on the result of searching the indices, some groups of data files are read. Access pattern: random accesses, including both read and write; no reuse of data, but since the size of a read request is not always 8K, there are reuse at the block level (a block is 8K bytes and is often the granularity of caching). For more detailed information on these applications, see my OSDI94 paper: @inproceedings{CFL94b, author = \"Pei Cao and Edward W. Felten and Kai Li\", title = \"Implementation and Performance of Application-Controlled File C aching\", booktitle = \"Proc. The events that are traced all come with a time stamp, which is the ``time'' field in ``struct tracerecord'' (see ``iotrace.h''). kernel I/O events: MYTRACE_RWEND: the kernel finished the processing of a ``read'' or ``write'' system call; (so the time between the ``read'' or ``write'' system call and the MYTRACE_RWEND event is the time it took the kernel to process this call.) MYTRACE_RDBEGIN and MYTRACE_RDBEGIN2: a disk read request is issued to the disk; (the flags are different because they are issued in different routines, MYTRACE_RDBEGIN in bread and MYTRACE_RDBEGIN2 in breada); MYTRACE_RDEND and MYTRACE_RDEND2: the read request issued in MYTRACE_RDBEGIN or MYTRACE_RDBEGIN2 has just finished; MYTRACE_RARDBEGIN: Ultrix has a one-block-lookahead prefetching algorithm; that is, if block K of file A is read, and the kernel see that the last read to file A is to block K-1, then the kernel prefetches block K+1. MYTRACE_BUSYEND: if a ``read'' or ``write'' system call finds that the block it wants to read is marked ``busy'', that is, an I/O is currently in progress for this block, then it waits till the busy bit is turned off. This happens, for example, when a readahead was issued for this block in the previous read system call. MYTRACE_BUSYEND record the time when the busy bit on the block is cleared and the process can read or write the block. MYTRACE_BWRBEGIN: a disk write request is issued; note that although user processes always wait for the read request, they don't necessary wait for the write request. MYTRACE_BWREND: if the above write request is synchronous, then this event record the time when it finishes; MYTRACE_RDBEGIN_INBREAD: a disk read request is issued in the ``bread'' routine in ufs code; MYTRACE_RDEND_INBREAD: the time when that request is finished; (MYTRACE_RDBEGIN_INBREAD and MYTRACE_RDEND_INBREAD should always appear in pairs) i_num is only meaningful for the system call events; you should ignore the i_num field for all other events; . i_dev is meaningful for most events; it records the dev number of the device to which the I/O is issued; . iotrace.h: header file for the trace records and event identifiers; rec_trace is the macro the kernel source uses to record an event; readrec.c: a library routine for my simulator; it reads the tracerecords from a trace files and return a generic record to be used by my simulator; it ignores the kernel events; (it may not be that useful to you.)",
    "ground_truth": "other"
}