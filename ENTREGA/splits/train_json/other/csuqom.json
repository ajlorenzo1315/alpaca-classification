{
    "TÃ­tulo": "Java for C++ Programmers",
    "Cuerpo": "To test this procedure in a C++ program, we might use a ``main program'' like this: #include <iostream.h> #include <stdlib.h> extern \"C\" int random(); Note that the first parameter is SortTest , not SortTest.class or SortTest.java because it is the name of a class , not a file. Thus, we had to make sort and main member functions (called ``methods'' in Java) of a class, which we called SortTest . The main method does not return any value (it is of type void ). Since you don't have a choice, Java doesn't have a special notation like C++ does to indicate when you want to use a pointer. As in C++, objects are instances of classes . Like all objects in Java, you can only point to them, but unlike a C++ variable, which is treated like a pointer to the first element of the array, a Java array variable points to the array object. int x = 3;   // a value int a[];     // a pointer to an array object; initially null int[] a;     // means exactly the same thing a = new int[10]; // now a points to an array object a[3] = 17;   // accesses one of the slots in the array a = new int[5]; // assigns a different array to a // the old array is inaccessible (and so // is garbage-collected) int[] b = a; // a and b share the same array object System.out.println(a.length); // prints 5 . Strings Since you can make an array of anything, you can make an an array of char or an an array of byte , but Java has something much better: the type String . You can't modify a string, but you can make a string variable point to a new string (as in numbers += \" \" + i; ). Constructors and Overloading A constructor is like in C++: a method with the same name as the class. A class can only extend one class, but it can implement any number of interfaces. We cannot call o.length() because class Object does not have a length method. In this case, however, we know that o is not just any kind of Object , but a String in particular. // ... later: t.join();  // wait for t to finish running cmd The constructor for the built-in class Thread takes one argument, which is any object that has a method called run . The rule is: No two threads may be executing synchronized methods of the same object at the same time. The methods wait() and notify() , which are defined in class Object and thus inherited by all classes, are made for this purpose. By calling wait() it releases the monitor lock so that producer threads can call put() to add more objects, but it keeps its place in line so it will get an object before other consumer threads that arrive later. Integer.MAX_VALUE           // 2147483648, the largest possible int Integer.parseInt(\"123\")     // the int value 123 Integer.toHexString(123)    // \"7b\", 123 in hex new Double(\"123e-2\").doubleValue() // the double value 1.23 // see also page 150 of the Java Book Character.isDigit('3')      // true Character.isUpperCase('a')  // false Character.toUpperCase('a')  // 'A' Vector A Vector is like an array, but it grows as necessary to allow you to add as many elements as you like. Thus you can insert objects of any type into it, but when you take objects out, you have to use a cast to recover the original type.",
    "ground_truth": "other"
}