{
    "TÃ­tulo": " Simon User Guide ",
    "Cuerpo": "Actions parameters in SAL do not take list-valued arguments, hence the all modifier is not to be used. For FIND-OUT and SATISFY goals, Simon will use SAL actions, as follows. If, for example, Simon has failed on the second goal conjunct above, you want Simon to attempt to find a NEW binding for (firstname ?p ?d) that hasn't been tried yet. So, after all the possible bindings from the model have been tried, Simon will try action A. (call-op ( *) ) There are two ways to invoke an operator: Call it directly (as in Rodney),  for example: (finger-firstname ?firstname ?domain) Use the call-op construct,  for example: (call-op (finger-lastname ?lastname ?domain) ?goal) Whereas it always calls the operator in the first case, Simon will perform checks on the goal if you use call-op (the second case). If the goal is not satisfied, this call-op action will fail. Normally, the parameters passed to operator execution (e.g. ?officemate, !phone and !pt) should also be bound, but notice that if the goal is satisfied before calling operator, the operator will not execute and thus the parameters will not be bound. [For a more complete example see FIND below] FIND This new action allows for a conditional iteration over a list or literal bindings. If you provide an optional goal as its second argument, try will try all the statements until the goal is satisfied. The goal can either be the parameter passed by Simon into an action (for example, ?goal ), or a literal. If it is a literal, Simon will also try to bind the variables in the literal. Here is a simple example of how try works: (try ?goal t) In this example,  Simon will try action A and see if goal ?goal is satisfied. For example,  the ?goal parameters in most SAL actions are bound to these objects. Some of them may be fixed in the next release but some are more open questions to be poundered upon. Try statments will only backtrack if it is the last statement of an action. This is unwieldy if, for example, we use a new variable inside a progn, and then need to reference it in the code following the progn. Partial objects are variables that have a set of constraints but do not have enough information to form or bind to an object. Example: (achieve (and (find-out (firstname ?p \"Terrance\")) (find-out (person.domain ?p \"cs.washington.edu\")))) Here we're specifying that ?p is an object that has the attributes firstname and person.domain that we know about,  but we don't know the lastname so we cannot completely specify a person object to bind to ?p. Ultimately you can set the default for what is interesting for you in a variable *print-enabled* which is a list of what is interesting, if you're interested you can look at interface.lisp and customize the variable.",
    "ground_truth": "other"
}