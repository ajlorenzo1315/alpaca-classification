{
    "TÃ­tulo": "ZPL Program Walk-Through",
    "Cuerpo": "The accompanying ZPL program solves the Jacobi computation: Jacobi : Given an array A , iteratively replace its elements with the average of their four nearest neighbors, until the largest change between two consecutive iterations is less than delta . For this example A will be a two dimensional array, and the program will generate its own data: A is initialized to 0.0, except for its southern boundary, which is set to the constant 1.0 in all positions. 1 /*                      Jacobi                                  */ 2 3 program jacobi; 4 5 config var n       : integer = 10;                -- Declarations 6            delta   : float   = 0.0001; 7 8 region     R       = [1..n, 1..n]; 9 10 direction  north   = [-1, 0]; south = [ 1, 0]; 11            east    = [ 0, 1]; west  = [ 0,-1]; 12 13 procedure jacobi();                               -- Entry point 14 var A, Temp : [R] float; 15     err     :     float; 16 17              begin 18 [R]              A := 0.0;                        -- Initialization 19 [north of R]     A := 0.0; 20 [east  of R]     A := 0.0; 21 [west  of R]     A := 0.0; 22 [south of R]     A := 1.0; 23 24 [R]              repeat                           -- Main body 25                      Temp := (A@north+A@east+A@west+A@south) / 4.0; 26                      err  := max<< abs(A-Temp); 27                      A    := Temp; 28                  until err < delta; 29 30 [R]              writeln(A);                      -- Output result 31              end; Figure 1: ZPL program for the Jacobi computation. The [R] specifies the region of A to be assigned, which in this case is all of A . Compare with similar computations expressed in other languages that must manipulate individual elements: Fortran 77 C Pascal DO 10 I = 1,N      for (i = 0;i < n;i++) {       FOR I:=1 TO N DO DO 10 J = 1,N       for (j = 0;i < n;j++) {       FOR J:=1 TO N DO 10 A(I,J) = 0.0               a[i][j] = 0.0;                A[I,J] := 0.0; } } Even Fortran 90, another array language, is more cumbersome because of its required range specification: A[1:N,1:N] = 0.0                     !FORTRAN 90. Concepts like \"regions,\" explained momentarily, simplify ZPL, because the programmer can think more abstractly, and leave the low level details like indexing and looping to the language. Thus, (Line 14), var   A, Temp : [R] float; declares two n x n array variables, A and Temp , composed of floating point numbers (called \"real\" in some languages) with indices given by region R . Directions are used to transform regions, as in the expression north of R (Line 19). By prefixing a statement with a region specifier, which is simply the region name in brackets, the operations of the statement are applied to all elements in the array. Thus, (Line 18), [R]  A := 0.0; assigns 0.0 to all n^2 elements of array A with indices in R . Extending the array A with boundaries and initializing their values is the role of the next four lines, (Lines 19-22), [north of R] A := 0.0; [east  of R] A := 0.0; [west  of R] A := 0.0; [south of R] A := 1.0; The region specifier [ d of R] defines the index set of a region adjacent to R in the d direction; the statement is then applied to the elements of the region. Thus, [north of R] defines the index set which is a \"0th\" row for A , and the assignment A := 0.0 initializes these elements. The successive effects of these initialization statements are illustrated in Figure 2. Update A with the new iteration (Line 27). All statements are executed in the context of the R region, since the repeat statement is prefixed by the [R] region specifier. The statement, (Line 25), Temp := (A@north+A@east+A@west+A@south)/4.0; finds for each element in A the average of its four nearest neighbors and assigns the result to Temp . An expression A@ d , executed in the context of a region R , results in an array of the same size and shape as R composed of elements of A offset in the direction d . As illustrated in Figure 3, A@ d can be thought of as adding d to each index, or equivalently in this case, shifting A . To compute the largest change of any element between the current and the next iteration, (Line 26), more elementwise array operations are performed. This means that the ZPL compiler is frequently successful at finding opportunities to optimize the program.",
    "ground_truth": "other"
}