{
    "TÃ­tulo": "CS 766 HW #2 Hints and FAQs",
    "Cuerpo": "The weights used should be based on the values a=.4, b=.25, and c=0.05. These should be scaled so that integer arithmetic, not floating point, is used in the convolution operation. More correctly, if the result of convolving the above mask at a pixel is x, then the rescaled and rounded result should be computed as  (x + 8)/16 since division truncates. What does it mean to subtract two images? vscale can be useful for initially scaling your two input images so that the splined result is more interesting. Since the Laplacian images have both positive and negative values, with a range of -255 to 255, what is the best way to store these images? Whenever you do an integer division operation, be sure to compute a rounded result by doing (a + (b/2))/b instead of a/b. How are the windows from the two input images determined when the images are arbitrary sizes? After aligning the center pixels of the two input images, there is some n x m area where the two overlap. Make the n x m left image by using the n x m window of the first image that is centered on its center point. Similarly, construct an n x m right image from the second input image. You can either use these n x m images as input to your programs (stopping at a level of the pyramid where n or m = 1), or else by first padding the n x m images to be of size (2**k + 1) x (2**k + 1), although padding will likely introduce some artifacts. How is the Expand operation defined, and why is there a 4 in the formula? An \"incorrect\" implementation is: tmp = 0 for m = -2 to 2 for n = -2 to 2 tmp = tmp + w(m,n) * image((row+m)/2, (col+n)/2) store tmp instead of a \"correct\" version like: tmp = 0 for m = -2 to 2 for n = -2 to 2 if (row+m mod 2 = 0 and col+n mod 2 = 0) then tmp = tmp + w(m,n) * image((row+m)/2, (col+n)/2) store 4*tmp In the correct version, suppose row and column are both even, say 10. Then you actually use a 3x3 window on the input image [row values: (10-2)/2, 10/2, (10+2)/2 and column values (10-2)/2, 10/2 and (10+2)/2]. And thus you should multiply your result by 4 so that the effective sum of weights is 1. In the incorrect version (still assuming row and column to be even), you are effectively truncating (row+m)/2, (col+n)/2 for m,n = -2..2. Thus you are still using a 3x3 window on your input image, but some values in this window are repeated. The effective weights for the window are: .0900 .1950 .0150 .1950 .4225 .0325 .0150 .0325 .0025 summing up to 1.0. For row odd, column even etc, you can similarly compute the effective weight matrices and see that the results are not similar for the two algorithms.",
    "ground_truth": "other"
}