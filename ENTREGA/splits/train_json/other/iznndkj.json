{
    "TÃ­tulo": "CS 537 - Introduction",
    "Cuerpo": "Now they are cheap ( or expensive!) and ubiquitous. Hardware trends: vacuum tubes, core memory, punched cards -> transistors, magnetic tapes -> integrated circuits, disks -> VLSI (computer on a chip) main frame ($1 million and up) -> mini $50K - $1M; workstation $10K - $50K -> micro (pc) $1K - $10K -> network computer $500 and up (??) One user at a time. Same person was programmer, operator, and end-user (who wants something done) -> multiprogrammed (more than one \"job\" at a time) (to improve utilization -- e.g. spooling) -> time-sharing (multiple interactive users) -> single-user pc or ws (come full-circle?) More regular, uniform (instead of lots of idiosyncratic devices) Easier to program (e.g., don't have to worry about speeds, asynchronous events) Closer to what's needed for applications: named, variable-length files, rather than disk blocks multiple ``CPU's'', one for each user (in shared system) or activity (in single-user system) multiple large, dynamically-growing memories (virtual memory) Resource principle The goal of an OS is to mediate sharing of scarce resources Q: What is a ``resource''? expensive devices need to share data (database is an ``expensive device''!) Problems: getting it to work at all getting it to work efficiently utilization (keeping all the devices busy) throughput (getting a lot of useful work done per hour) response (getting individual things done quickly) protection limiting the effects of bugs (preventing idiots from ruining it for everyone) preventing unauthorized access to data modification of data use of resources (preventing bad guys from ruining it for everyone) Bottom-up View (starting with the hardware) Hardware (summary; more details later) components one or more central processing units (CPU's) main memory (RAM, core) I/O devices bus, or other communication mechanism connects them all together CPU has PC pointing to next instruction to execute fetches instructions one at a time from location specified by PC increments PC after fetching instruction; branch instructions can also alter the PC responds to \"interrupts\" by jumping to a different location (like an unscheduled procedure call) Memory responds to \"load\" and \"store\" requests from the CPU, one at a time. CPU gets back status and small amounts of data by issuing \"load\" requests. Issues an interrupt to the CPU to indicate that it is done. And it would change with a faster disk! Better solution: Process 1: for (;;) { start I/O wait for it to finish use the data for something } Process 2: for (;;) { do some useful computation } Operating system takes care of switching back and forth between process 1 and process 2 as ``appropriate''. Space problem Most of the time, a typical program is \"wasting\" most of the memory space allocated to it. Looping in one subroutine (wasting space allocated to rest of program) Fiddling with one data structure (wasting space allocated to other data structures) Waiting for I/O or user input (wasting all of its space) Solution: virtual memory Keep program and data on disk (100-1000 times cheaper/byte). Top-Down View (what does it look like to various kinds of users?) Doesn't know what an OS is (or care!) May not even realize there is a computer there. Writes software for end users. What processes are. All rights reserved.",
    "ground_truth": "other"
}