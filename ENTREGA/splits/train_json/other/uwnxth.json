{
    "TÃ­tulo": "An Improved-Version of a Parallel Object-Tracker in RivL",
    "Cuerpo": "MIME-Version: 1.0 Server: CERN/3.0 Date: Sunday, 01-Dec-96 18:54:03 GMT Content-Type: text/html Content-Length: 34844 Last-Modified: Saturday, 18-May-96 02:22:04 GMT An Improved-Version of a Parallel Object-Tracker in RivL An Improved-Version of a Parallel Object-Tracker in RivL http://www.cs.cornell.edu/Info/People/barber/potrivl/potrivl.html Sicco Tans ( stans@cs.cornell.edu Jonathan Barber ( barber@cs.cornell.edu ) CS664 Final Project Professor Ramin Zabih Department of Computer Science Cornell University 0.0 Table of Contents 1.0 Abstract 2.0 Introduction 3.0 RivL and the Generic Parallel Paradigm 3.1 The RivL Graph 3.2 Generic Parallel RivL 4.0 RivL's Object Tracker 4.1 The Object Tracker Script 4.2 The Algorithm behind im_search 4.3 Parallelizing im_search 4.4 Problems with im_search and Generic Parallel RivL 5.0 Parallelizing im_search in RivL 5.1 A Course-Grain Parallelization Scheme 5.2 Implementation #1:  An Inefficient Parallel im_search 6.0 Implementation #2:  Persisent Parallel Object Tracker 6.1 Passing Sequence Information 6.2 The Contents of Shared Memory 6.3 Setting up Shared Memory 6.4 Updating Shared Memory 6.5 A New Semaphore 6.6 Implementation Issues 7.0 Performance Results 8.0 Extensions & Improvements 9.0 Conclusions 10.0 References Go Back 1.0  Abstract The fields of multimedia image processing and Computer Vision are converging. RivL is a multimedia software processing package that, given a set of images (or a set of a sequence of images), can efficiently process these multimedia streams and generate an outgoing image (or a sequence of images). In particular, the scheme does not work for Object Tracking. In Section 6.0, we describe our implementation of a parallel Object-Tracking RivL operation. Go Back 3.0   RivL and the Generic Parallel Paradigm Go Back 3.1  The RivL Graph We begin our discussion of RivL by introducing the RivL Evaluation Graph. Each slave process should run on a different processor. According the figure above, the amount of data fetched from each read node is no longer a function of the output of the write node, but is now a function of: the process's Logical ID# the total number of processes and, is a function of the write node's output That is, each RivL process is responsible for computing a different, independent portion of the final output data, which is based on the above parameters. Each slave and the master process computes their appropriated portion of the output image. Go Back 4.0  RivL's Object-Tracker Go Back 4.1  The Object-Tracker Script The RivL Object Tracker is implemented as a tcl script which executes a set of RivL image operations. Given an image sequence and a model to look for, the job of the RivL Object Tracker is to determine where an object model resides in a given image, for each frame in a sequence of images. For every adjacent set of images, the Tracker performs the following sequence of operations:  it first smooths (using the RivL im_smooth operation) and then edge-detects (using the im_canny operator, which is a Canny Edge-Detector [ 3 ]) Next . The sequence of images above illustrates the output of RivL's Object Tracker. If an interesting region is found, the Slave process will further sub-divide that region into smaller regions, and place each sub-divided region as a job \"to-do\" onto the low priority queue. The only shared data  is the job queue, which is simply a data structure that contains pointers to different portions of Next . Of course, the dependence on the size of the images in the sequence is the reason that a particular shared memory segment can only be kept around for one sequence of images. The easiest way to keep track of the structures in shared memory turned out to be putting them in the same order every time and maintaining some global information as to the location of the structures in shared memory relative to the start of the shared memory segment. Go Back 7.0  Performance Results We tested our implementation of the parallel RivL object-tracker on a 24 frame MPEG- sequence. We tested the performance of our implementation using a master process, and 1 to 4 slave processes. Unfortunately, our current performance results indicates not only that our implementation is slower than the first implementation, but that it is also slower than the sequential version. Dan Huttenlocher, W.J Rucklidge, A Multi-Resolution Technique for Comparing Images Using the Hausdorff Distance, Proceedings of the IEEE Computer Vision and Pattern Recognition Conference (1993), 705-706 (with W.J.",
    "ground_truth": "other"
}