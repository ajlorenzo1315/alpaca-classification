{
    "TÃ­tulo": "Classes",
    "Cuerpo": "One of the most apparent differences between a class and a struct is that, in addition to having \"data members\" like a struct, a class can have \"member functions\" or \"methods\". We can think about these member functions as being operations that all objects that belong to the class can do. void greet(char who[]); }; Notice that we have added an additional member, called greet to the class Alien. This member is a prototype for a function which takes an array of characters and produces no return value. It could look like this: void Alien::greet (char who[]) { cout << \"Hello \" << who << \", my name is \" << name << \" and I am from \" << homePlanet << \".\\nLet's be friends for ever!\\n\"; } This looks a lot like a normal function definition. We have a return type (void), we have a parameter list (char who[]) and we have some code making up the function body. What is different is the function name Alien::greet . For example, there might be a Robot class and it might have a greet method too. In order to specify which greet method we are providing the body for, we need to give the class name. That is why our function is called Alien::greet . You can read this name as meaning \"the greet method for the Alien class.\" We have defined the greet method for the Alien class. We can call the greet functions for both by the code: ... // this appears somewhere, maybe in main... yoda.greet(\"Dad\"); darth.greet(\"Mom\"); ... We call a method for a particular object (variable) by using \"the dot operator\". The reason that we call variables like yoda and darth \"objects\" is that they are, in an abstract sense, entities that can receive messages and interact with each other. When we make the calls, the variables \"name\" and \"homePlanet\" will correspond to whichever object makes the call. I am leaving them here because it doesn't make sense to remove them: First example: class Alien { public: char name[MAXSTR]; char homePlanet[MAXSTR]; int numLegs; int isDeadly; Alien::Alien (char nm[], char home[], int legs, int deadly) { strcpy(name, nm); strcpy(homePlanet, home); numLegs = legs; isDeadly = deadly; } Overloaded: class Alien { public: char name[MAXSTR]; char homePlanet[MAXSTR]; int numLegs; int isDeadly; (E.g. when you make an array of classes!) You can use = to assign one whole class to another: Generra = Gamera; You can also call the constructor explicitly to make an anaonymous value of a certain type and assign it: Generra = Alien(\"ET\", \"Home\", 2, 0); Alien:: Example where I use it to resolve name clash in constructor: Alien::Alien (char name[], char homePlanet[], int numLegs, int isDeadly) { strcpy(Alien::name, name); strcpy(Alien::homePlanet, homePlanet); Alien::numLegs = numLegs; Alien::isDeadly = isDeadly; } Constant member: class Alien { public: // ... Can also use them in calls: Alien Yoda(\"Yoda\", \"Dagobah\", 2, Alien::killer); This way we can hide the \"magic number\".",
    "ground_truth": "other"
}