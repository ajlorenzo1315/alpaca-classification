{
    "TÃ­tulo": " Tips for Assignment Three",
    "Cuerpo": "It is also not absolutely necessary that the abstract data types be classes; they can be structures if you are unfamiliar with C++. Point    [ X ]       Direction  [ dX ] Vector    [ Y ]       Vector     [ dY ] [ Z ]       (normal)   [ dZ ] [ 1 ]                  [  0 ] The homogeneous coordinate should be 1 if the vector represents a point in three dimensional space and 0 if it represents a normal vector, which has direction but no position. They will point in the right direction if they are transformed by the same matrix that transforms the points and then normalized to unit length. You will see how these operations are useful as we proceed with the assignment. Steps In this assignment, I found that it was helpful to think of the steps I would need to go through to do the assignment. Part One: Creating a Viewing Matrix You will need to create a matrix which will do all the transformations necessary. These parameters will be a view reference point (point vector), view point (point vector), and a view up vector (direction vector). The view up vector is the V vector mentioned in 12-2 and is the orientation of the head. The N on page 438 is the vector Vrp-Vp, while V is the view up vector that you have specified. Perspectivize the view, using the length of Vrp-Vp as d. The view plane will now look as so. Therefore, the easiest way to handle the normal vectors is to create another matrix that looks like this: [   Rot   ] [  Align  ] [ View on ] [ Z  axis ] Note that this has just one of the matrices from above. If you do a sheer or nonuniform scaling it will need to be in this matrix as well. Remember to normalize the normal vectors to unit length and to divide the point vectors by their homogeneous coordinate. You will need the point vector(including the z value), and the normal direction vector to make this calculation. In additon to a dxPerScan, it should have a dzPerScan and a dNormalDirectionVectorPerScan, which should also be calculated in makeEdgeRec and added to the z value and Normal Vector in updateActiveList. It will be helpful in this function to have a dzPerxpixel and a dNormalDirectionVectorPerxpixel which will be added to the z value and Normal Vector each time x is incremented. The equation which you will probably use for shading is equation 14-15 on page 508. The color that you read in from a file, if any, is the diffuse color. You can come up with an appropriate specular color. There is just one note here about the Zbuffer, which is a big array of z values.",
    "ground_truth": "other"
}