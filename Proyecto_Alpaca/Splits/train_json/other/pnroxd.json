{
    "Título": "Sin título",
    "Cuerpo": "The first pass will note the line numbers for each label. So, you will need two loops that pass over the code. One way to loop over the code would be: It would make sense to use associate() in the first pass and lookup() in the second pass. when you generate code, the number you put into the branch target field for the ba instruction would be the number -2. In particular, numbers will be supplied to you in binary. You can tell that by the fact that they are declared in C as int's. In C, an int is a binary represented integer (in two's complement). You will need to take binary ints, and place them into the bitfields described in chapter 8 of your book. To do this in C: Use the << operator to shift bits to the left. For example, to put the number -7 into a bit field from position 14 to 18 in the instruction: int instr;    /* the instruction */ int num\t      /* the number; contains the value -7, say */ /* first mask all bits to 0 except those we want to keep */ /* this is a pattern of 5 1's since we want to keep 5 bits */ num = num & 0x1f; /* now \"or\" them into the instruction */ instr = instr | num; Finally, when you have filled all the bitfields in the instruction, write the bits to stdout as follows: Does this mean that my assembler is not converting the assembly file correctly into machine code? Your assembler generated a bit pattern that the processor cannot interpret as an instruction. -- Is there any way I can look at the machine code produced by my assembler program? First, use \"od -X\": Instead of using Chapter 8 for this instruction, look at p. 386 in Appendix C. -- How can I send an error message to the terminal if output is redirected?",
    "ground_truth": "other"
}