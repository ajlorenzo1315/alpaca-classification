{
    "TÃ­tulo": " Lecture notes - Chapter 4 - Data Representation",
    "Cuerpo": "use 1 bit of integer to represent the sign of the integer 1101   is -5 to get the additive inverse of a number, just flip (not, invert, complement, negate) the sign bit. 4 bits, -7 to +7 n=4, - 2**3 + 1     to    2**3 - 1 -8 + 1         to     8 - 1 a logical operation done on a single bit the complement of 1 is 0. the complement of 0 is 1. they will have a 0 in the MSB (but it is NOT a sign bit!) to get the additive inverse of a 2's comp integer, 1.  take the 1's comp. to add 1 without really knowing how to add: start at LSB, for each bit (working right to left) while the bit is a 1, change it to a 0. when a 0 is encountered, change it to a 1 and stop. this representation allows operations on the biased numbers to be the same as for unsigned integers, but actually represents both positive and negative values. -------------- how to change an integer with a smaller number of bits into the same integer (same representation) with a larger number of bits. What we need is an algorithm for translating character strings to the integers they represent, and visa versa. S is one bit representing the sign of the number E is an 8 bit biased integer representing the exponent F is an unsigned integer It gets put back into the number (giving 24 bits of precision for the mantissa) for any calculation, but we only have to store 23 bits. An example:   put the decimal number 64.2 into the standard single precision representation. first step: get a binary representation for 64.2 to do this, get binary reps. for the stuff to the left and right of the decimal point separately. 64  is   1000000 so a binary representation for .2  is    .001100110011. . 133 in 8 bit, unsigned representation is 1000 0101 this is bit pattern used for E in the standard form. the values are often given in hex, so here it is",
    "ground_truth": "other"
}