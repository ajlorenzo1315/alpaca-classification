{
    "TÃ­tulo": "A Resolution Independent Video Language",
    "Cuerpo": "Image Operations 2. These optimizations include classical programming language optimizations, such as common subexpression elimination and out of order execution, image and video specific optimizations, such as computing only those images that will affect the output, and an optimized memory manager. Rivl provides a video data type and video operators that are format and resolution independent. We have implemented an interpreter for Rivl as an extension to the Tcl language [11] , an approach that allows us to easily embed Rivl in other applications. Since Rivl is an extension of Tcl, Rivl programs have access to all the primitives of the Tcl language. This class provides functions to convert between images and sequences, and to map image operations over the frames of a sequence. Table 1: Image and sequence primitives ----------------------------------------------------------------------------------------------- Type          Image         Sequence     Description operations    operations Input/Output  im_read       seq_read     Read image/sequence from disk im_write      seq_write    Write image/sequence to disk Geometric     im_trans      seq_shift    Translate an image in space / shift a sequence in time im_scale[C]   seq_scale    Scale an image in space / scale a sequence in time im_rotate[C]               Rotate an image [C = around its center] Assembly      im_crop       seq_crop     Crop the specified region to make a new image/sequence im_concat     seq_concat   Concatenate multiple images/sequences end to end im_overlay    seq_overlay  Overlay multiple images/sequences in place Conversion    ims_to_seq    seq_to_ims   Convert between a list of images and a sequence seq_map      Apply a script to each image in the sequence Transforms    im_fade                    Fade the image by a specified percentage im_resample                Resample the image at a specified size im_blur                    Apply a blur filter to the image im_mask                    Make transparent all pixels below a certain intensity Figure  1: Output from program 1 for p = 0.1, 0.4, 0.7 Figure  2: Fractal program and output for n= 1,2,3 <-- The Rivl Language 2. Sequence Operations A sequence, the Rivl abstraction for video, can be thought of as a set of time-stamped images. The following Rivl fragment assembles the first 10 seconds of the sequence raiders.mpg and the sequence bobo.mpg, writing the result to out.mpg (all files are MPEG format): set raiders [seq_read raiders.mpg] set bobo [seq_read bobo.mpg] seq_crop! To this end, seq_map performs the following additional substitutions: %t:      Substitute the time stamp of the current image, in seconds %l:   Substitute the length of the sequence in seconds %p:  Substitute the relative time of the current image: %t divided by %l Using this mechanism, fade-to-black can be expressed seq_map $clip {im_fade %1 [expr 1-%p]} When combined with sequence assembly operations, seq_map simplifies the expression of effects that are often used in transitions between two parts of a movie. The second optimization, introduced by Shantzis[ 10 ], is to compute only those regions of each intermediate image that affect the final result. Figure 5b shows the regions computed for each intermediate image in our example graph. Figure 6 shows the sequence graph for program 2 , in which each node corresponds with one line of the program. In the forward pass, we build an image graph corresponding to output frame T. As we traverse the sequence graph, each seq_read and seq_map node we encounter adds node(s) to the image graph. Figure  7: Generating the image graph for t = 220.0 Figure  8: Image graph for entire sequence The optimizations of section 3.1 are used to process the compound image graph to produce the output images, along with two additional optimizations: image subgraph reuse and direct-transfer detection. The Rivl memory manager detects this case, freeing each image only when it is no longer needed in the current graph evaluation. Figure  10: (a) Dividing large image / (b) Representing sparse image To illustrate the utility of Rivl's memory management policy, we consider the execution of the scrolling titles program (program 2) under a standard memory model in which the entire image is read into a virtual memory buffer for the duration of the program. They are: Graph restructuring: Combining or reordering nodes in the graph for speed Result-region calculation: Computing only the parts of an image that affect the output Direct transfer detection: Copying compressed data directly to the output when possible Image subgraph reuse: Sharing common subexpressions in the image graph Image caching: Caching images if they are needed later in the graph evaluation Image subdivision: Dividing large images into manageable pieces <-- The Rivl Interpreter <-- Table of Contents 4.",
    "ground_truth": "other"
}