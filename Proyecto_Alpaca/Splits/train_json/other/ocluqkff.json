{
    "TÃ­tulo": "CS 537 - Fix for Project 2",
    "Cuerpo": "If your algorithm 1 deadlocks, you have some other bug in your program. It is very likely that the deadlock you're seeing is not due to this problem, but to some more ``ordinary'' bug in your program. (To turn off the ThreadScheduler, simply comment out the line sched.start() .) If it deadlocks only under Windows, it is more likely (but not certain) that the bug is caused by this problem. The problem arises because synchronized methods contain calls to other synchronized methods and it is possible to set up a circular pattern of calls between distinct objects. At that point t1 and t2 are deadlocked. B.putForks() only calls A.giveFork() if B has previously requested the fork from B, but A.takeForks() only calls B.requestFork() if A has not previously requested it. In class, I said that a more complicated scenario could be devised to show that deadlock is still possible, but couldn't think of one on the spot. Assume B is eating, so he has the forks he shares with A and C, and A has the fork she shares with C. Let t A , t B , and t C represents the threads for philosophers A, B, and C. Suppose C gets hungry just before B finishes eating, and A gets hungry just after. C gets hungry, so thread t A enters C.takeForks() and calls B.requestFork(), which returns false because B is eating. B finishes eating, so t B enters putForks(), and seeing that there is a request from C, tries to call C.giveFork(). She already has the fork she shares with C, so t A tries to call B.requestFork(), but is blocked because t B is still active in B.putForks(). Thread t C is resumed and tries to call A.getFork(). while (forksHave < forks.length) { for (int i = 0; i < forks.length; i++) { if (forks[i].have) forksHave++; else if (!forks[i].haveRequested) { if (phil[forks[i].neighborId].requestFork(forks[i].forkId)){ forks[i].clean = true; forks[i].have = true; forksHave++; } else forks[i].haveRequested = true; } } } if (forksHave < forks.length) { forksHave = 0; try { wait(); } catch (InterruptedException e)  {} } } state = EATING; } The trick is to split takeForks into two pieces. If no such fork exists because all forks are here it returns -1 and sets the local state to EATING. for (;;) { int forksHave = 0; // Number of forks currently owned for (int i = 0; i < forks.length; i++) { if (forks[i].have) forksHave++; else if (!forks[i].haveRequested) { forks[i].haveRequested = true; return i; } } if (forksHave == forks.length) { state = EATING; return -1; } try { wait(); } catch (InterruptedException e)  {} } } private void takeForks() { for (;;) { int i = neededFork(); if (i == -1) return; if (phil[forks[i].neighborId].requestFork(forks[i].forkId)) giveFork(forks[i].forkId); // give myself the fork } } At the end of class, Patrick Gaffney pointed out that there's still a danger of a race condition. The call B.requestFork() has updated B's data structure to indicate that B does not have it, but A.giveFork() has not had a chance to update A's variables to show that A has it. This is not necessarily a problem, but the code has to be carefully written so that it can cope with this unusual situation. For example, if t B is allowed to run next, it may become hungry, and seeing that it no longer has the fork, it may call A.requestFork(), which will find that A doesn't have the fork that is being requested.",
    "ground_truth": "other"
}