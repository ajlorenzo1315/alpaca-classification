{
    "TÃ­tulo": " Mumit's STL Newbie guide ",
    "Cuerpo": "Const'ness of iterators *NEW* Using iterator tags Miscellaneous examples/notes Copy between lists: right way and wrong way Copy between maps Adaptors in STL: not1 , stack , queue , etc remove vs erase List of List 's in STL Sorting a container Sorting a list of user defined objects Sorting a vector of user defined objects Shuffling a deck of cards Deducing type from iterator Persistent STL 236 examples from ObjectSpace A look at ObjectSpace STL<ToolKit> Template instantiation with GCC *NEW Visibility of template definitions Manual instantiation Using GCC 2.7.0 template repository mechanism Internet resources available Acknowledgments About this Document I started this document as a wastebasket for my random notes and thoughts on STL when I first started learning and using it heavily during winter of 1994. Currently most of this document really deals with issues that are hard to find in manuals, such as how to create containers of pointers, or how to manage manual instantiation of STL template with GCC, etc. eg., if there is a library class X that you cannot modify, you can define the operators == and < externally as following: bool operator== (const X& x1, const X& x2) bool operator<  (const X& x1, const X& x2) Note that you may not need the < and == operators for some compilers if your code doesn't use the algorithms that need these operators (eg., sorting and such things). Here we add an object, x , of type X , to the end of the list . When you need to store objects derived from a (or a set of) base objects in a container. // struct compare { bool operator ( ) ( const int * i1 , const int * i2 ) const { return * i1 < * i2 ; } } ; void print ( int * i ) { cout << \" \" << * i ; } int main ( int , char * [ ] ) { list < int * > list1 ; // // create a list of new'd integers. push_back ( new int ( i * i ) ) ; } cout << \" List of int*: ( \" ; for_each ( list1 . << endl ; } return 0 ; } Pointers and STL Back to index Example of a pointer wrapper for storing in STL containers If you have to store pointers in STL containers, especially the sorted collections such as set and map , you might want to wrap the pointers into a simple class that works as a holder for the pointer ( who cleans up the memory afterwards ?) See here for an example): #include < stl.h > #include <iostream.h> // // Let's say you want to put pointers to X into multiple STL containers. end ( ) , print ) ; cout << \" ) \" << endl ; return 0 ; } And the output is: List of XPtrWrapper: ( 4 0 16 1 9) Set of XPtrWrapper : [ 16 9 4 1 0] Deque of XPtrWrapper : ( 4 0 16 1 9) Pointers and STL Back to index How do I store derived objects in STL containers? end ( ) ; ++ it ) { const PtrWrapper < Base > & w = * it ; w ( ) -> identify ( cerr ) ; cerr << \" \" ; } cerr << endl << endl ; return 0 ; } And here's the output: (derived1 101) (derived2 201) (derived2 202) (derived1 102) (derived2 203) Pointers and STL Back to index Checking for an item in a map This is from a bug we found in our code a while back. o ] Error 1 Of course the correct way is to use list<int>::const_iterator instead as shown here: #include < stl.h > void foo ( const list < int > & list1 ) { list < int > :: const_iterator it = list1 . For example, you can use either a list or a deque as the underlying container for both stack and queue , but you cannot use a list for priority_queue because list does not support a random_access_iterator needed by priority_queue (use a deque or a vector instead). For the containers that do not support random access iterators, such as list , STL containers typically have a sort member function that does the job. Visibility of template definitions One major complication with GCC is that all the template definitions must be visible at the point of instantiation (which may not be the case with Borland, but I wouldn't know about that), and if you have the template class members defined in a .cc file that is not included in the declaration file ( .h ), then you'll get undefined errors. Visibility of template definitions Back to index Manual instantiation of templates with GCC Let's start with a trivial program, where a list is the only STL data type used, specifically list<int>. so now I can create a file template-inst.cc: #include < stl.h > template class list < int > ; and compile this w/out -fno-implicit-templates option and link it with f1.o and we're in business. Let's say you are going to use the following templated data types in STL: list<int> deque<int> and the following algorithms: copy (to ostream_iterator) copy (list to deque) for_each (on list objects) #include < stl.h > // include everything for simplicity. end ( ) , back_insert_iterator < list < int > > ( list1 ) ) ; cout << \" ==> List1: \" ; copy ( list1 . ==> For_each List1:  1103527590 377401575 662824084 1147902781 2035015474 368800899 1508029952 486256185 1062517886 267834847 Manual instantiation of templates with GCC Back to index Using GCC 2.7.0 template repository mechanism Let's start with a trivial program, where a list is the only STL data type used, specifically list<int>.",
    "ground_truth": "other"
}