{
    "TÃ­tulo": "The UW DC Prototype",
    "Cuerpo": "Date: Tue, 10 Dec 1996 03:35:22 GMT Server: NCSA/1.4.2 Content-type: text/html The UW DC Prototype Our Dynamic Compilation Prototype Phased compilation is a compilation strategy in which the code compilation process is completed in stages: at traditional, static, compile-time, at link-time, at load-time, and (on demand) at run-time. This is in contrast to incremental compilation, the primary goal of which is to reduce compilation time, especially recompilation time. Profs. Susan Eggers and Craig Chambers and several students make up the University of Washington Dynamic Compilation Group. We are focusing on optimizing code performance at run-time using information available only at run-time. Two separate compilers are involved in our model of dynamic compilation: a static compiler and a dynamic compiler. The dynamic compiler uses the partially compiled dynamic regions and other information generated by the static compiler to generate executable code for the dynamic regions. For our prototype dynamic compilation system, designed and built by Joel Auslander and Matthai Philipose , we have enhanced the Multiflow compiler to act as the static compiler, and built a dynamic compiler that is automatically invoked at run-time. A new version of the region is compiled at run-time for each set of values these variables have at the beginning of the dynamic region. Furthermore, these annotated variables must be invariant throughout the dynamic region, and are called run-time constants . The static compiler automatically identifies all values in the region that are derived from this programmer-specified set of run-time constants, which can then be considered run-time constants (and can be used as the basis for specialization) as well. In particular, if the arguments to an arithmetic operation, a comparison, or even a memory load are compile-time and run-time constants, then the result is assumed to be a run-time constant. The static compiler then splits each dynamic region into two pieces of code, set-up code and machine-code templates . References in the machine-code templates to run-time constants cannot be resolved at static compile time, since their values are not determined until run time; therefore the machine-code templates contain holes in place of these values. It then executes the directives, selecting and copying the desired machine-code templates and filling in the holes based on the values computed by the set-up code, to produce the final optimized machine code for the dynamic region. For all future executions of the dynamic region with the same run-time-constant values, the generated machine code is executed directly without invoking the dynamic compiler or the set-up code. Our dynamic compiler only manipulates \"nearly compiled\" templates, and so is designed to be very fast. However, even if the dynamic compiler is very fast and the code generated is very efficient, the code that is dynamically compiled will generally have to be executed many times in order to recoup the cost of dynamic compilation through enhanced performance. For this reason, the regions of code to be specialized at run-time and the variables on which the dynamic compiler is to specialize must be carefully selected. Last updated August 8, 1996.",
    "ground_truth": "other"
}