{
    "TÃ­tulo": "Parallel Raytracing in CC++",
    "Cuerpo": "Raytracing in itself is easily parallelised, as the screen can be split up into several areas and each area can be given to one processor. One also needs to worry about balancing the load well between the processors, depending on the complexity of the scene. The method traces the path of those rays (from the eye to the scene) and calculates the intensity and color of that ray, depending on the ray's path and reflections. The problem with this method is load balancing. The problem with this method is that doing anti-aliasing is no longer straight forward as all the current pixel's neighbours are on different processors, and performance becomes an issue if a processor has to go across the network (connecting the processors) to anti-alias each pixel. Each slave node requests work from the master and goes back to ray trace its strip. This goes on till all the strips have been ray traced. Another problem is antialiasing. It needs the next row (which is on the another processor) to antialias it. In the other, we send the unquantized last and first rows of each strip (in addition to the quantized values of all but the last row of each strip) so that the master node can antialias the last rows of all the strips therefore avoiding any redundant computation. At this time this version has a bug in it so all performance results discussed in the next section are with respect to the first implementaion. A dispatcher is essentially the master processor that dishes out the work and the tracer does the actual raytracing of each strip. ( We timed the disk writes and ray tracing in the serial version and found raytracing a pixel is 600 times more expensive than writing it to disk). We found a problem with CC++ in that when data was being sent to another processor by means of a data transfer functions there is unnecessary copying of the data before it is packaged in the data transfer function. Sync variables are used when the dispatcher is waiting for the tracers to complete their work, so no cycles are wasted in waiting in a dummy loop but the dispatcher's main loop is suspended till the sync variable is set by the function of the dispatcher that decides there are no more strips to be traced. 4.Performance Speedup The graph below shows speedup vs. number of processors, where speedup is defined as the ratio of the time taken to run the serial implementation to the time taken to run the parallel version. This is because of the bottleneck created on processor 1 which also needs to act as the dispatcher and thus the tracer on processor 1 isn't as efficient as the tracers on the other processors. At higher granularity again the efficiency goes down. 5.Experiences and Conclusions CC++ We found CC++ to be overall a very effective language to work with in that it allowed us to think about parallelism in a structured manner. Also, since each processor needs only the first row of the next block to antialias its last row, it is almost certain that the neighbouring processor would have completed raytracing that row and the processor can therefore immediately use that data.",
    "ground_truth": "other"
}