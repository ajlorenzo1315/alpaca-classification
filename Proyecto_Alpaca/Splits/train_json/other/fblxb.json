{
    "TÃ­tulo": "CS 302 Section 70 Lecture Notes - Week 10",
    "Cuerpo": "Notes: Heaps: Remember that we've seen binary search represented as a tree, i.e. 1 3 5 6 8 9 11 Then if we need to search the left part of the list, the new middle is 3; if we need to search the right part, though, the middle is 9, and so on down the tree. LIST(3) is 4. Heapify takes a node and moves it down the tree until that node satifies the heap property (if it was okay to begin with, it won't be moved at all). So we want to move the node down in the tree. The heap property still fails there, so we need to switch the 2 and the 5. 6 5 4 3 2 8 1 Note that this is still not a heap (the 8 is a problem), but all nodes on the path from where the 2 was to where the 2 is now satisfy the heap property. BuildHeap: We have a way of providing the heap property to a path in the tree; now we need to be able to do it to all paths (once it's true for all paths, then our tree will be a heap). Start with the the last node that has children (LIST(3), in our example above). Then Heapify the node before that in the list (LIST(2)). So  / \\   is a heap. 7 So  / \\   is a heap. Suppose we're given Heaps H1,H2 and a and a node X; the tree X / \\ H1  H2 can only violate the heap property at one place...X. In our example, we made a heap out of the tree starting with LIST(3), then a heap out of the tree starting at LIST(2). We now have the largest element in the array at the end of LIST. So LIST(1) to LIST(7) is the heap; LIST(8) is ignored. Heapify LIST(1). We'll get a new Heap based on the first 7 elements of so the next time thru, for example, switch 2 and 7, decrease your heap size by 1, and Heapify the top. 5 4 2 3 1 7 8 So now the 2 largest elements are in order, at the back of the list.",
    "ground_truth": "other"
}