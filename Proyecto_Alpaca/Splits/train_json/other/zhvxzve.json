{
    "TÃ­tulo": "CS 537 - Programming Assignment II",
    "Cuerpo": "For this project, you will be required to implement two solutions to a generalization of the Dining Philosophers problem, using the multithreading and synchronization capabilities of Java to simulate the action of multiple processes competing for shared resources. For example, philosopher 0 shares fork 0 with philosopher 1, fork 10 with philosopher 5, and fork 4 with philosopher 4. Algorithm I The simplest algorithm for the diners problem is for a hungry philosopher to grab all the forks she needs (i.e. all the forks surrounding her) in some order and then start eating. This algorithm can lead to deadlock, but if each philosopher always picks up forks in increasing order by fork identifiers, deadlock cannot occur (you should be able to prove this statement). It does not matter how the forks are numbered, so long as no two of them have the same number. Algorithm II Chandy and Misra call this algorithm a \"hygienic\" solution to the diners problem. In our algorithm, a non-eating philosopher defers requests for forks that are clean and satisfies requests for forks that are dirty.'' Chandy and Misra show that this algorithm is deadlock-free provided the initial placement of forks is acyclic in the following sense: Draw an arrow head on each edge of the graph G so that it points towards the process currently holding the fork. Because a philosopher can ask for all of his forks at once, he may not have to wait as long to eat as in Algorithm I. Philosopher 8 has all his forks (so he can eat right now if he is hungry), while poor philosopher 0 has none of hers. Fork 11, which is shared by philosophers 6 and 1, is currently held by philosopher 1. This placement is not acyclic (and hence could lead to deadlock) because of the cycle from 3 to 4 to 9 to 7 to 2 and back to 3. Specifying the Graph The specification of the philosopher graph (that is, the number of philosophers and forks and an indication of which which forks are shared by which pairs of philosophers) is given in a file. class Graph { Graph(String fileName) throws FileNotFoundException; // Constructor:  reads the graph from a file public int numberOfPhilosophers(); public int numberOfForks(); public int numberOfNeighbors(int phil); // How many neighbors does phil share forks with? The forks are arranged around each philosopher in increasing order of fork id so that forkId(phil,0) is always the lowest-numbered fork shared by phil. Algorithm I For the first solution, you should define a Semaphore class and create an instance of this class to represent each fork. Each philosopher will need to remember (in a field of class Philosopher ) his own state, as well as several pieces of information about each fork he shares: whether he has it, whether it's clean or dirty, whether it has been requested by his neighbor, and perhaps more. /** Called by this philosopher when he gets hungry to get his forks. **/ public synchronized void giveFork(int forkId) { find i such that theGraph.forkId(myId, i) == f; record that \"this\" philosopher has his ith fork and that it is clean; notify(); } You should give a lot of thought to the design of the data structures used to record the state of a philosopher and his forks. For example, exactly one of the two philosophers should think he has the fork at any given time.",
    "ground_truth": "other"
}