{
    "TÃ­tulo": "Static Layer Analysis for C Programs",
    "Cuerpo": "Preliminary work on software tools to allow both the enforcement of a layered structure during forward engineering, and the extraction of layered structure from pre-existing C language source code is presented. In 1979 Parnas wrote about building software as layers of virtual machines, and defined the \"uses\" relation for components in a software system [P79]. The \"uses\" relation itself is defined such that component A uses component B if the correct operation of A depends upon the existence of some correct implementation of B.  Parnas argues that if a system is built in such a way that a uses hierarchy exists for its components, then each level of that hierarchy comprises a usable subset of the complete system. This paper presents some preliminary work on two tools ( lcc and lce ) to allow both the enforcement of a layered structure during forward engineering, and the extraction of a layered structure (if one exists) from pre-existing C language code. Layered C Checker (lcc) lcc is a simple tool intended for use in a forward engineering context, in which the enforcement of a layered design structure on the development of source code is desired. It can be set to allow recursive functions, since recursive functions would normally be reported as an error (a function which calls itself is calling a function on the same level as itself, which is contrary to normal layered structure). Additionally, some flexibility may be desired in the number of layers which invocations can cross before lcc reports them as errors. The strict definition of a layered system in which a function at level i can only call functions at level i - 1 may be easily attainable at an abstract level by inserting \"dummy\" functions at the intervening layers across which a multi-layer invocation would otherwise reach, but it is typically not desirable to introduce lots of functions in the source code itself whose only purpose is to call other functions. Following is some sample output of running a version of lcc on a simple program which does not have a strict layered structure, followed by a run of lcc on itself (it turns out that lcc itself does have a strict layered structure): 896 cindy:layered_c >lcc -2 -l -r foo.c Functions by level: level 1 foo.c: my_abs foo.c: my_fact foo.c: i_power foo.c: d_power level 2 foo.c: my_cos foo.c: my_exp level 3 foo.c: my_func level 4 foo.c: find_root level 5 foo.c: main In this approach, a special keyword (@level) is added to C in order to allow the assignment of levels to different functions. While the version of lcc using this second approach is currently much more usable than the version implementing the first approach, it is the author's belief that bringing layer support closer to the language level (as in the first approach) is ultimately more desirable, given the addition of a complete C parser (with the addition of the @layer syntax) to lcc. Layered C Extractor (lce) lce is similar to lcc in that it checks C source code to see if the boundaries between levels are maintained. However, rather than using source annotations to determine the level to which a function is assigned, lce will automatically generate the mapping of functions to levels. lce works by first extracting a call graph from the source in the same manner as lcc. A level counter is incremented at every level of recursion, and if a function is called from the current level, the level of the that function is set to 1 + the current level, as long as it is not already deeper. This may not, however, be the optimal assignment of layers. lce was modified to recognize the @level annotations used by lcc. lce fixes only the level of the functions which are annotated, and still uses a depth-first search to map levels to the rest of the functions. To test whether this 4 layer crossing was truly necessary, the calling function was annotated to be fixed at one level lower than the depth-first search had placed it. Note: as far as lce can tell, the following functions will never be invoked (though they may be through function pointers): ../hw5/agrep2.04/utilities.c: subset_pset ../hw5/agrep2.04/utilities.c: eq_pset Future Work Few concrete conclusions can be drawn at this point about the usefulness of these tools, as they have yet to be used for any real software engineering project.",
    "ground_truth": "other"
}