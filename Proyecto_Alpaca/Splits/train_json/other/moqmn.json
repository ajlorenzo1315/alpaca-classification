{
    "TÃ­tulo": "CS 537 - Processes, Part II (Deadlock) ",
    "Cuerpo": "Only only process can use the resource at a time, but once it's done, it can give it back for use by another process. A process requests a (serially reusable) resource from the OS and holds it until it's done with it; then it releases the resource. We can find out whether there is a deadlock as follows: for (;;) { find a node n with no arcs coming out of it; if (no such node can be found) break; erase n and all arcs coming into it; } if (any nodes are left) there is a deadlock; This algorithm simulates a best-case scenario: Every runnable process runs and causes all events that are expected from it, and no process waits for any new events. Then, since it will never wait for anything, it cannot be part of a deadlock, and we can erase it. It may also contain processes that are not part of the cycle but are waiting for processes in the cycle, or for processes waiting for them, etc. The algorithm will never erase any of the nodes in a cycle, since each one will always have an outgoing arc pointing to the next node in the cycle. The ``events'' they are waiting for are release of resources. Draw an arc from a process to a resource if the process is waiting for the resource, and an arc from the resource to the process if the process holds the resource. The same algorithm as before will tell whether there is a deadlock. If there is a cycle, the algorithm will never erase any part of it, and the final graph will contain only cycles and nodes that have paths from them to cycles. Resource Types Often, a request from a process is not for a particular resource, but for any resource of a given type. For example, a process may need a block of memory. To model this, we will assume there there some number m of resource types , and some number E[r] of units of resource r , for each r between 1 and m . The most ``eager'' approach is to check whenever we do something that might create a deadlock. Thus the we only have to check for a deadlock when a process becomes blocked because it made a request that cannot be immediately granted. Even if there are some processes that are not deadlocked, they may all be blocked for other reasons (e.g. waiting for I/O). Thus another reason to check for deadlock is that a process has been blocked on a resource request ``too long.'' It is possible for a process that is holding resources to request more. We can attack condition (3) either by forcing a process to allocate all the resources it will ever need at startup time, or by making it release all of its resources before allocating any more. As we have already seen, a cycle in the waits-for graph is necessary for there to be deadlock.",
    "ground_truth": "other"
}