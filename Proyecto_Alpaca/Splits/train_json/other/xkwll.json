{
    "TÃ­tulo": " Lecture notes - Chapter 1 - Some basics.",
    "Cuerpo": "when a problem is large, it needs to be broken down -- we \"divide and conquer\" one way is by introducing a hierarchy (level), and solving the problem at each level example: design of a computer 1. transistors available 2. gates, flip flops 3. components, like registers and adders 4. it is a different level in the abstraction of program design. to help the situation, introduce assembly language -- a more human readable form of machine language. lastly, if we had a program that translated HLL programs to assembly language, then we'd have it made. -----------                  ------------ HLL ---> | compiler|---> assembly --->| assembler|--->machine -----------     language     ------------    language this course deals with the software aspects of assembly language, assemblers and machine language. It also deals with the hardware aspects of what the computer does to execute programs. It is an introduction to study of COMPUTER ARCHITECTURE: the interface between hardware and software. I can design a computer that has hardware which executes programs in any programming language. From experience (in the engineering community), we know that the hardware that executes HLL programs directly are slower than those that execute a more simple, basic set of instructions. CPU -- controls the running of programs executes instructions makes requests of the memory memory -- where programs and program variables are stored handles requests from the CPU to execute an instruction, the CPU must be able to request 3 things from memory: read:   CPU specifies an address and a read operation memory responds with the contents of the address write:  CPU specifies an address, data to be stored, and a write operation memory responds by overwriting the data at the address specified instructions and operands are stored in memory. it does this by the use of an extra variable contained within and maintained by the CPU, called a PROGRAM COUNTER, or PC the contents of the variable is the address of the next instruction to be executed. modify the above CPU steps: 1.  fetch the instruction at the address given by the PC It is convenient to think of it as step 2. notice that this series of steps gets repeated constantly -- to make the computer useful, all that is needed is a way to give the PC an initial value (the first instruction of a program), and to have a way of knowing when the program is done, so the PC can be given the starting address of another program. the cycle of steps is very important -- it forms the basis for understanding how a computer operates.",
    "ground_truth": "other"
}