{
    "TÃ­tulo": "OOPS Group Publications",
    "Cuerpo": "We describe the basic strategies of the system, and present details of our interface for C++. An Analysis of the Effects of Memory Allocation Policy on Storage Fragmentation . The study of dynamic memory allocation has been dominated by measurement of performance of allocators with random input streams of requests. A useful and accurate measurement of fragmentation is presented that is based on the amount of waste at the point of peak memory usage. The allocators are used in memory allocation simulations to determine their respective fragmentation. A representative set of real program allocation traces is used in the simulations, and compared with randomized traces, to show that the application's patterns of allocation are an important factor in the allocator's performance and that studies based on synthetic traces are fundamentally flawed. Postscript (923KB) Paul R. Wilson, Sheetal Kakkad, and Shubhendu S. Mukherjee. In \"Analysis and Development of Demand Prepaging Policies,\" Horspool and Huberman show that it is possible to design prefetching memory policies that preserve a \"stack\" inclusion property, much like LRU, allowing them to simulate these policies for all sizes of memory in a single pass through a reference trace. In particular, their policies are not properly timescale relative --events occuring on a timescale that should only matter to some sizes of memory adversely affect replacement decisions for memories of very different sizes. Position paper for the 1993 ACM OOPSLA Workshop on Memory Management and Garbage Collection , Washington D.C., September 1993. We survey basic garbage collection algorithms, and variations such as incremental and generational collection. We survery basic garbage collection algorithms, and variations such as incremental and generational collection; we then discuss low-level implementation considerations and relationships between storage management systems, languages, and compilers. Throughout, we attempt to present a unified view based on abstract traversal strategies, addressing issues of conservatism, opportunism, and immediacy of reclamation; we also point out a variety of implemetation details that are likely to have significant impact on the performance. Texas: An Efficient, Portable Persistent Store . In Persistent Object Systems: Proceedings of the Fifth International Workshop on Persistent Object Systems , pages 11-33, San Miniato, Italy, September 1992. A key component of the design is the use of pointer swizzling at page fault time, which exploits existing virtual memory features to implement large address spaces efficiently on stock hardware, with little or no change to existing compilers. Long pointers are used to implement an enormous address space, but are transparently converted to the hardware-supported pointer format when pages are loaded into virtual memory. This address translation is largely independent of issues of data caching, sharing, and checkpointing; it employs operating systems' existing virtual memories for caching, and a simple and flexible log-structured storage manager to improve checkpointing performance. Caching Considerations for Generational Garbage Collection . Postscript (237KB) More papers, a bibliography on heap management, and the source code for Texas Persistent Store are available via anonymous ftp at ftp.cs.utexas.edu:/pub/garbage .",
    "ground_truth": "other"
}