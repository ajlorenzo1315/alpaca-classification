{
    "TÃ­tulo": "tt4",
    "Cuerpo": "You can think of a specification as a legally binding contract How the power company generates the power is not part of the specification Hydro power, or Coal, or hamsters on treadmills Software specifications Functions are software components. /* exp(x,n) == x^n, for n >= 0. */ int exp(int x, int n) { return (n == 0) ? 1 : exp(x, n-1) * x; } signature : a function taking two int's and returning an int correctness specification : if n >= 0, then exp( x , n ) will yield x n Signatures The number of parameters that a function takes, together with their types, and  the type of the result it returns are its signature . Note that the body of the function doesn't affect the signature In a function application, the number and type of the arguments must match the signature. exp(5, 3, 1)    is wrongexp(\"Hello\", 1) is wrongprintf(exp(5, 1))   is wrong Correctness Specifications A correctness specification states what a function does without saying how it does it. /* == x^n, for n >= 0. The postcondition describes the result in terms of the arguments, e.g., x n . In general, a correctness specification states: If the arguments in a function application satisfy the precondition, then the application will yield a value that satisfies the postcondition. e.g., if n >= 0, then exp( x , n ) will yield x n . If the precondition is not satisfied, the result is not defined, i.e., can be anything (or diverge). E.g.,  exp( x , n ) diverges, for n < 0. exp(5, -1)(-1 == 0) ? 1 : exp(5, -2 - 1) * 5) * 5exp(5, -2 - 1 ) * 5 * 5 exp(5, -3) * 5 * 5... A function should never be called with arguments that do not satisfy the precondition. */ int fourth(int x) { return (exp(x, 4)); } The specification should not describe the implementation, which the implementor has freedom to change. */ because x n is not defined for x = 0 and n = 0. */ or /* == x^n, for n >= 0 and x != 0, and   == 1, for n == 0 and x == 0. */ int count(int lo, int hi, int id) { return lo > hi ? id : count(lo + 1, hi, id); } For example count(1, 2, 0) 1 > 2 ? */ int sumSquares(int lo, int hi){ return lo > hi ? */ int factorial(int n) { return multIntegers(1,n); }",
    "ground_truth": "other"
}