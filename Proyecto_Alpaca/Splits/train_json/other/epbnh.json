{
    "TÃ­tulo": "CS 537 - Programming Assignment #3",
    "Cuerpo": "Your assignment is to write a program that reads in the trace data and simulates the CPU scheduling. CommandName is a character string (maximum length of 10 characters) that contains the name of the program; StartTime is the time in 10 millisecond increments (100ths of a second) since midnight - this is the time that the program arrived in the system; CPUTime is the total CPU time, in seconds, used by this program; IOCount records the total number of bytes of disk I/O done by this program. The lines in the trace files are sorted by program starting time. The \"clock\" in your simulator will be a variable that holds the value of the current time. A disk I/O will complete: The process that completed its I/O will be placed back in the appropriate run/ready queue. A new process will arrive (be ready to start): In this case, the current time of the simulator matches that the arrival time of one or more jobs in the trace file. Scheduling Algorithms The details of the particular scheduling algorithm (you will implement several) should be isolated in a single class. All your program, except for the scheduling algorithm, should be the same for the different versions. Each process runs until it completes its time slice, blocks for disk I/O, terminates, a disk I/O completes, or another job arrives (i.e., if a new process arrives or a disk I/O completes during the running process's time slice, the running process is interrupted). As with RR, each process runs until it completes its time slice, blocks for disk I/O, terminates, a disk I/O completes, or another job arrives. Any time a process is interrupted (by a new process or by I/O completion), it is placed back in the queues, at the end of the queue , for the correct priority. When a process does an I/O operation, it blocks until the operation is completed. If the CPUTime does not divide evenly by the number of I/O operations, then the last CPU burst will be smaller than the other ones and not be followed by a disk I/O. Some examples: If the CPUTime is 20 and the number of I/O operations is 4, then the process will need to start an I/O operation after each 5 ms of execution. So, the process will execute 5 ms, then do an I/O, execute another 5 ms, then do an I/O, and so on. If the CPUTime is 23 and the number of I/O operations is 4, then the process will execute exactly as the above case, with an additional 3 ms CPU burst after the last disk I/O. If the CPUTime is 5 and the number of I/O operations is 10, then the process will start one I/O operation after each 1 ms of exectution, with 6 I/O operations being done together at the end of the last CPU burst. As soon as one operation is completed, the next can start (with no time in between). The ACT is the average of this value for all jobs in the trace file. In the last version, it is a priority queue sorted by remaining CPU time.",
    "ground_truth": "other"
}