{
    "TÃ­tulo": "CSCI 570: Analysis of Algorithms",
    "Cuerpo": "Handouts , exams and problem sets may be found below and on linked documents. Grades Handouts Syllabus Red-Black trees Leftist Heaps Amortized Analysis , including Skew Heaps and Splay Trees Competative Analysis of Online Algorithms Assignments 1 , 2 , 3 , 4 and 5 Problem Set 1. 1.3-7; 1-2; 2.1-2,3,8; 2.2-6, 8; 2-2,3,5; 3-1; 4-4,5,7 Due: January 25, 1996 Solutions: here Problem Set 2. Due: February 9, 1996 Solutions: here Problem Set 3. Give a tight bound on the competitiveness of LRU for the caching problem, assuming that your cache can hold at most k pages. (Here you're counting the number of cache misses .) Every element has a pointer at level 0, which connects all of them into a sorted linked list. Suppose you're given such a list; to insert the next element x into the list, search for where it goes in the level 0 list and splice it in. Then i = 1; while (flip() != tails) { add x to the list at level i; i++; } Sketch a proof that (1) the resulting list has height O(lg n) with high probability, assuming that the probability of heads is p , 0 &< p &< 1; and (2) inserting or finding an element in a data structure constructed in this way requires O(lg n) time. Suppose that i give you a piece of paper with n lines drawn across its surface. You repeat the following: choose one of the remaining lines at random, and cut the paper along it. Then hold onto the piece that has the dot (origin) and throw the rest away. Throughout this process, the total number of times that you cut across any of the remaining lines is expected to be O(n ln n) . Use this fact to design an algorithm which, given n half-planes, each containing the origin, computes their intersection in expected time O(n lg n) by incrementally adding one half-plane at a time. They are put into a binary tree such that they have an inorder ordering (binary search tree property) with respect to keys, and a heap ordering with respect to priorities. Let x be any element and A the set of ancestors of x in the random treap. Then X = # {keys < x and in A} + #{keys > x and in A} Use this obvious fact to give a precise value for the expected depth of x , when x is the m th largest element in the tree. Recall that to insert an element, you proceed as in a binary search tree, then attach a random priority, and rotate up the tree until heap-ordering has been restored. Then show that the expected number of rotations is 2. 34.2-4 This suggestions came up a few times in class: 34.4-4 * 34.5-3 Graph review: 23.4-3 and 4, 25.2-3 Due: Thursday April 10th Solutions: here Exams take-home midterm exam take-home final exam, available in html or in postscript .",
    "ground_truth": "course"
}