{
    "TÃ­tulo": "CS 537 - Processes",
    "Cuerpo": "Processes with very little private memory are called threads or light-weight processes . Of course, a thread can only ``see'' an object if it can reach that object from its ``base'' object (the one containing its run method, or from one of its local variables. Those objects are in the shared heap, but since one thread has no way of getting to the object created by the other thread, these objects are effectively private. But both copies of obj1 and the copy of obj4 in the main thread all point to the same (shared) object. After the call, both the parent (the process that called fork() ) and the child are both executing at the same point in the program. k = fork(); if (k == 0) { str = \"the child has value \"; return 10; } else { str = \"the parent has value \"; return 39; } } This program starts with one process executing main() . If the value is zero when a process calls down , that process is forced to wait (it goes into blocked state) until some other process calls up on the semaphore. shared Semaphore mutex = new Semaphore(1); void deposit(int amount) { mutex.down(); balance += amount; mutex.up(); } We assume there is one semaphore, which we call mutex (for ``mutual exclusion'') shared by all processes. If only one process wants to make a deposit, it does mutex.down() , decreasing the value of mutex to zero, adds its amount to the balance, and returns the value of mutex to one. If two processes try to call deposit at about the same time, one of them will get to do the down operation first (because down is atomic!). If there were three processes trying at the same time, one of them would do the down first, as before, and the other two would be forced to wait. It will be blocked forever because no other process can grab the mutex semaphore to add an item to the buffer (and thus call full.up() ). class Philosopher implements Runnable { int i;    // which philosopher public void run() { for (;;) { think(); take_forks(i); eat(); put_forks(i) } } } A first attempt to solve this problem represents each fork as a semaphore: Semaphore fork[5] = 1; void take_forks(int i) { fork[i].down(); fork[i+1].down(); } void put_forks(int i) { fork[i].up(); fork[i+1].up(); } The problem with this solution is that it can lead to deadlock. A semephore (always called mutex in our examples) is associated with a shared variable or variables. 2 monitor class BankAccount { private int balance; public void deposit(int amount) { balance += amount; } // etc } The keyword monitor tells the compiler to add a field Semaphore mutex = 1; to the class, add a call of mutex.down() to the beginning of each method, and put a call of mutex.up() at each return point in each method. class Condition { public void signal(); public void wait(); } A condition variable is like a semaphore, with two differences: A semaphore counts the number of excess up operations, but a signal operation on a condition variable has no effect unless some process is waiting. monitor BoundedBuffer { Buffer b; Condition nonfull, nonempty; public void enter_item(Object item) { if (b.isFull()) nonfull.wait(); b.enter_item(item); nonempty.signal(); } public Object remove_item() { if (b.isEmpty()) nonempty.wait(); item result = b.remove_item(); nonfull.signal(); return result; } } In general, each condition variable is associated with some logical condition on the state of the monitor (some expression that may be either true or false). In this particular case, you can get away with notify because there cannot be both producers and consumers waiting at the same time. Each process may directly name the other, or there may be some sort of mailbox or message queue object to be used as the destination of a send or the source of a receive . Some versions of Unix allow memory to be shared between processes, and some have other ways for processes to communicate other than pipes.",
    "ground_truth": "unknown"
}