{
    "TÃ­tulo": "CS 766 HW #3 Hints and FAQs",
    "Cuerpo": "Date: Mon, 11 Nov 1996 17:30:50 GMT Server: NCSA/1.5 Content-type: text/html Last-modified: Tue, 07 Nov 1995 18:56:24 GMT Content-length: 4861 CS 766 HW #3 Hints and FAQs CS 766 HW #3 Hints and FAQs How is the edge magnitude information in `edge' accessed? The array `edge' should be accessed as edge[row][col]. It might mean that there are too many snake points. There is a problem with the Williams and Shah algorithm in this case. That is, the curvature at each of those points will be undefined if one follows the algorithm to the letter. (Make sure you use '>' in this condition and not '>='). What if snake point i goes to the old position of point i+1 for all i (modulo the total number of snake points)? You do not have to deal with this problem. If it ever happens when you are developing your code or during the demo, you can simply stop the snake and restart with a new snake. It should contain the value of the coordinates of the new position of a point. But if you are moving, say points[i], you should NOT change points[i] directly and then call MoveSnakePoint(points[i], points, i, num_points) Rather, you should create a temporary Point variable, say loc_min, define loc_min.row and loc_min.col appropriately and then call MoveSnakePoint(loc_min, points, i, num_points) MoveSnakePoint() is itself supposed to copy the coordinates from loc_min to points[i] in addition to moving the point on the display. When calculating the derivatives for Econt and Ecurv, how should the boundary conditions, i.e., when i=0 and i=n, be handled? On page 19 in the Williams and Shah paper there is a description of how to compute this term. Since we want this to be a measure of distance, you should use: - | d - | v  - v   | | i    i-1 To normalize this value to be in the range [0..1], divide by the largest value of this expression from the 9 values computed for the 9 possible positions of v_i in the 3 x 3 neighborhood centered at the current point. For both the continuity and curvature energies, the paper states that the value at a point under consideration should be divided by the largest value in the neighborhood to which the point may move. I am interpreting this to mean the largest value in the neighborhood around the original snake point. For example: +-+-+-+ |1|2|3| +-+-+-+-+   X = the snake point |4|*|5| |   * = the point under consideration +-+-+-+-+ |6|7|X| |   So, the question is:  which largest value do I use? The one that +-+-+-+-+   is computed using the neighborhood around X or do I compute based | | | |   upon the neighborhood of the point under consideration? So, for +-+-+-+   example, if I wanted to normalize the value computed at *, I would figure out the largest value at 1,2,3,4,*,5,6,7,X becuase that is *'s neighborhood. The way I read the paper * should be normalized by using the largest value from the 9 values in the 3 x 3 neighborhood centered at X, not *.",
    "ground_truth": "unknown"
}