{
    "TÃ­tulo": "CSE 143 Grading Policy",
    "Cuerpo": "Functionality The main goal of programming is to create a working program. In many cases, the programs that we assign you will be underspecified -- that is, we won't tell you exactly how they should work. For example, a partial specification might ask you to write a program that draws mazes on the screen, without telling you exactly what input you should get from the user or what kind of maze to make. In addition, you might detail the way in which the maze should be constructed. (rows x columns) _________ Start  _ ___ __| | | | | | |___|____  End Although there is rarely a single, correct way to handle ambiguities in a partial specification, be sure that your full specification is in the spirit of the partial specification. For example, writing a program that always generated \"mazes\" of the following form probably isn't what we had in mind: How long would you like your maze to be? _________ Start  _________  End The bottom line is that in order to know if your program is working, you have to decide what it's supposed to do. You'll generally be asked to submit a full specification with your program (in the comments or a cover sheet, for example) so that we know what your specific goals and choices were. Generally, we'll supply you with a few test cases that will test aspects of your program. If your program works on our test cases, that doesn't necessarily mean that it's correct and you're done! Make sure to write a few test cases of your own to check some of those ambiguous cases that your full specification describes, and use these to demonstrate to us that your program works as you specified. Software Engineering Software engineering is all about how a program is put together -- it involves the division of the program into separate, logical modules; defining reasonable interfaces between these modules; and commenting your code so that it's clear to others (like your TA!) We're not looking for the single monolithic piece of code that has everything thrown into it without any sense of order -- that technique might have some benefits in the stereo world, but they rarely do in software. To this extent, you will be graded on how well your program is constructed, in addition to how well it works. Did you make reasonable decisions as to how the code should be organized and interface between modules? Etc. As backwards as it seems, a program that is well structured and documented, but doesn't quite work (comment reading: I think the problem is somewhere in this routine), is often more impressive than one that works but is completely indecipherable. Strive for the best of both. Other Questions?",
    "ground_truth": "unknown"
}